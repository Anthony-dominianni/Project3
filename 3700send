#!/usr/bin/env python3

import sys
import socket
import datetime
import json
import time

MSG_SIZE = 1500
DATA_SIZE = 1472
TIMEOUT = .2
SEQN = 0
SEQUENCE_TO_MESSAGE = {}

def log(string):
  sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")
  sys.stderr.flush()

def send_next_packet(seqn, sock, dest):
  msg = {"sequence": seqn, "data": "", "ack": False, "eof": False}
  overhead = len(json.dumps(msg))
  msg["data"] = sys.stdin.read(DATA_SIZE - overhead)

  # Map sequence number to message and store
  SEQUENCE_TO_MESSAGE[seqn] = msg
  log(f'Adding sequence number {seqn} to map')

  if len(msg["data"]) > 0:
    assert (len(msg) <= DATA_SIZE), f"ERROR: Datagram is longer ({len(msg)}) than {DATA_SIZE} bytes!!!"

    if sock.sendto(json.dumps(msg).encode('ascii'), dest) < len(msg):
      log("[error] unable to fully send packet")
    else:
      log("[send data] " + str(seqn) + " (" + str(len(msg["data"])) + ")")
    return seqn + len(msg["data"])
  return seqn

def send_and_wait_for_acks(sock, dest):
  global SEQN
  while True:
    try:
      result = sock.recvfrom(MSG_SIZE)
      if result:
        (data, _addr) = result
        data = data.decode('ascii')

        try:
          decoded = json.loads(data)

          earliest_sequence_not_acked = min(SEQUENCE_TO_MESSAGE.keys())
          next_sequence = earliest_sequence_not_acked + len(SEQUENCE_TO_MESSAGE[earliest_sequence_not_acked]["data"])

          # If there is an ack, send next packet
          if decoded['ack'] == next_sequence:

            log(f"[recv ack] {SEQN}")

            del SEQUENCE_TO_MESSAGE[min(SEQUENCE_TO_MESSAGE.keys())]

            # Try to send next packet; break if no more data
            new_seq = send_next_packet(SEQN, sock, dest)

            if new_seq == SEQN:
              return
            SEQN = new_seq
        except (ValueError, KeyError, TypeError) as e:
          log("[recv corrupt packet]")

    except socket.timeout as e:
      log(f"[error] did not recieve ack for {SEQN}")

      earliest_sequence_not_acked = min(SEQUENCE_TO_MESSAGE.keys())

      msg = {"sequence": earliest_sequence_not_acked, 
        "data": SEQUENCE_TO_MESSAGE[earliest_sequence_not_acked]["data"],
        "ack": False, "eof": False}

      log('retransmitting')
      log("[send data] " + str(earliest_sequence_not_acked) + " (" + str(len(msg["data"])) + ")")

      sock.sendto(json.dumps(msg).encode('ascii'), dest)

def main():
  # Bind to localhost and an ephemeral port
  ip_port = sys.argv[1]
  udp_ip = ip_port[0:ip_port.find(":")]
  udp_port = int(ip_port[ip_port.find(":")+1:])
  dest = (udp_ip, udp_port)

  # Set up the socket
  sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
  sock.settimeout(TIMEOUT)

  # Send first packet
  global SEQN
  updated_sequence_number = send_next_packet(SEQN, sock, dest)
  SEQN = updated_sequence_number

  # Now read in data, send packets
  send_and_wait_for_acks(sock, dest)

  for i in range(0, 10):
    sock.sendto(json.dumps({"eof": True}).encode('ascii'), dest)
    
  log('[completed]')
  sys.exit(0)

if __name__ == '__main__':
  main()
